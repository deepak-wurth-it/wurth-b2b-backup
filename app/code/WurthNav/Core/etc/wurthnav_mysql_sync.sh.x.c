#if 0
	shc Version 4.0.3, Generic Shell Script Compiler
	GNU GPL Version 3 Md Jahidul Hamid <jahidulhamid@yahoo.com>

	shc -f wurthnav_mysql_sync.sh 
#endif

static  char data [] = 
#define      msg2_z	19
#define      msg2	((&data[1]))
	"\327\271\265\070\076\374\213\242\325\243\135\175\257\320\376\034"
	"\323\343\170\267"
#define      xecc_z	15
#define      xecc	((&data[21]))
	"\275\334\141\243\227\057\005\011\060\115\162\135\360\310\054\225"
	"\140\346"
#define      lsto_z	1
#define      lsto	((&data[38]))
	"\062"
#define      chk1_z	22
#define      chk1	((&data[43]))
	"\246\220\354\246\254\103\276\146\325\346\227\053\013\056\222\160"
	"\152\266\333\106\300\312\164\377\256\246\316"
#define      tst1_z	22
#define      tst1	((&data[67]))
	"\225\231\012\057\272\206\353\070\203\204\363\333\174\376\152\202"
	"\330\236\333\237\203\265\343\147\007\046\343\333"
#define      rlax_z	1
#define      rlax	((&data[94]))
	"\372"
#define      opts_z	1
#define      opts	((&data[95]))
	"\214"
#define      chk2_z	19
#define      chk2	((&data[96]))
	"\215\176\055\231\177\145\273\313\101\353\043\076\243\374\271\215"
	"\045\377\330\130"
#define      pswd_z	256
#define      pswd	((&data[163]))
	"\242\111\207\365\360\027\342\226\346\075\343\303\322\112\313\371"
	"\056\246\244\256\310\121\006\117\111\030\224\241\020\117\140\263"
	"\231\350\251\212\377\213\041\345\310\004\251\233\117\164\224\310"
	"\200\224\312\236\360\376\074\070\333\326\214\244\201\172\307\207"
	"\260\322\342\375\123\015\253\067\055\230\314\057\110\365\370\310"
	"\212\302\147\172\300\244\262\233\172\077\100\374\271\007\203\152"
	"\332\146\150\055\164\023\144\241\254\061\320\364\046\310\275\260"
	"\213\044\053\114\310\336\350\103\036\050\077\330\060\303\102\012"
	"\052\252\070\236\276\234\077\152\315\020\137\364\331\034\245\144"
	"\101\321\260\012\257\230\115\316\301\215\246\361\120\351\374\172"
	"\224\064\031\122\321\130\275\237\150\035\223\102\072\070\246\173"
	"\011\127\205\271\357\323\207\260\140\056\242\261\027\237\054\254"
	"\323\105\376\245\236\274\104\007\332\330\111\024\021\357\217\032"
	"\106\025\324\066\350\134\347\111\212\212\372\242\051\046\116\375"
	"\153\115\242\011\012\346\020\344\276\131\370\317\111\210\352\220"
	"\236\277\306\206\033\256\317\246\070\312\111\141\360\227\136\134"
	"\345\000\145\357\347\166\324\246\320\315\165\032\126\140\252\364"
	"\037\161\173\073\037\113\342\127\025\053\271\005\303\027\141\251"
	"\030\307\231\377\076\155\245\017\072\033\051\221\174\324\205\175"
	"\033\071\054\344\212\062\063\323\112\307\165\133\027\325\016\261"
	"\275\267\073\275\103\134\242\014\140\114\250\257\301\074\054\334"
	"\165\131\300\000\213\364\324\326\274\111\062\324\037\100\205"
#define      text_z	1564
#define      text	((&data[848]))
	"\232\074\034\075\111\174\211\361\054\112\056\131\047\244\262\350"
	"\244\076\335\170\024\231\301\106\156\340\207\363\275\200\263\127"
	"\275\320\225\006\115\036\370\171\151\046\322\221\312\204\171\157"
	"\303\126\347\327\360\251\036\136\212\246\122\110\047\006\240\344"
	"\326\065\353\043\123\343\235\275\012\157\116\324\364\307\103\267"
	"\036\053\217\017\325\256\156\140\125\300\250\174\306\110\141\235"
	"\176\114\301\322\060\136\217\073\316\335\017\302\245\123\172\304"
	"\177\012\324\124\271\102\265\016\003\135\212\312\246\354\147\044"
	"\071\050\366\151\207\205\244\125\143\264\030\011\010\223\315\210"
	"\235\241\335\126\344\222\145\350\357\357\262\225\333\032\272\025"
	"\103\260\176\312\066\043\037\231\330\067\242\341\313\160\151\150"
	"\022\106\277\367\330\044\337\307\024\222\135\360\254\027\005\357"
	"\310\204\272\376\250\331\230\200\021\073\142\334\253\313\105\276"
	"\021\005\265\352\051\224\262\076\047\017\056\323\047\064\303\357"
	"\270\175\356\141\127\206\342\151\301\104\106\154\017\213\053\041"
	"\220\340\013\272\165\275\371\234\314\050\160\364\134\063\343\025"
	"\261\321\166\011\130\130\162\031\234\270\206\254\104\261\315\325"
	"\221\330\220\007\225\211\243\142\262\023\126\017\107\072\044\370"
	"\014\233\002\144\364\164\176\221\055\004\075\161\265\013\107\107"
	"\344\327\116\171\141\361\334\023\005\063\042\114\156\107\105\172"
	"\343\107\337\327\274\135\151\352\142\247\133\027\262\243\136\226"
	"\172\255\020\334\237\355\357\244\040\022\361\216\132\066\011\075"
	"\176\351\025\073\106\176\045\250\045\201\300\330\044\037\157\237"
	"\314\177\173\153\155\153\020\215\176\001\034\330\070\215\077\251"
	"\236\002\352\330\171\136\326\175\347\363\174\261\136\252\066\130"
	"\174\117\221\016\103\207\120\212\206\112\354\151\133\302\213\142"
	"\161\050\364\144\011\054\064\314\245\263\276\075\210\073\060\031"
	"\072\331\034\203\064\355\102\136\246\134\014\324\056\257\033\150"
	"\363\271\147\373\371\147\017\037\243\165\042\110\254\071\026\265"
	"\111\232\127\267\136\324\045\317\073\157\213\105\043\226\304\032"
	"\362\222\353\235\150\240\053\155\351\352\072\000\172\070\147\207"
	"\336\115\007\372\013\347\216\336\352\271\156\364\207\164\004\202"
	"\106\273\334\062\304\275\162\147\365\235\201\200\034\264\033\212"
	"\072\047\321\022\061\020\243\045\333\325\307\056\265\125\124\227"
	"\127\053\177\343\275\266\161\335\137\265\276\360\021\366\323\356"
	"\041\325\101\263\017\140\000\077\015\216\121\100\226\124\004\175"
	"\034\310\365\346\076\217\327\133\330\213\362\176\262\345\073\166"
	"\130\343\056\306\152\225\010\164\315\145\352\265\260\256\023\054"
	"\032\136\344\213\020\200\141\117\360\115\115\320\271\223\335\354"
	"\062\004\031\133\124\276\255\074\027\276\177\255\223\310\046\251"
	"\202\260\340\106\350\064\046\125\154\321\243\271\002\064\117\362"
	"\110\057\240\072\364\056\057\203\033\212\262\121\302\157\335\257"
	"\147\301\110\370\336\325\257\303\035\150\366\125\367\334\010\245"
	"\076\050\020\341\062\105\027\104\374\372\267\023\253\132\172\010"
	"\300\231\142\040\221\111\023\274\151\163\177\242\353\100\141\250"
	"\156\240\341\053\204\174\270\252\103\216\111\072\261\066\245\170"
	"\244\002\347\233\146\042\352\164\152\076\350\060\100\012\154\137"
	"\226\362\140\306\203\354\160\061\056\017\133\047\054\365\000\075"
	"\045\022\066\014\007\145\251\377\313\365\375\202\017\200\312\066"
	"\046\363\026\051\166\232\273\152\035\021\120\201\253\336\322\104"
	"\063\201\270\143\146\347\242\364\250\235\226\057\371\102\344\257"
	"\373\064\041\112\202\072\020\124\037\342\167\062\340\360\276\322"
	"\045\372\043\272\257\306\026\045\122\105\237\336\241\346\330\137"
	"\251\046\221\142\102\161\364\067\034\200\320\360\060\062\070\140"
	"\340\324\361\277\153\057\076\335\205\330\042\277\215\126\120\030"
	"\336\242\055\103\266\373\022\133\161\151\176\205\046\016\140\101"
	"\040\177\205\312\160\042\242\275\034\221\257\305\127\353\161\221"
	"\306\006\304\011\300\264\120\033\272\236\315\146\054\212\173\025"
	"\130\313\221\170\252\010\213\102\202\350\047\243\300\341\222\220"
	"\307\240\063\170\144\320\137\344\310\253\351\367\114\010\107\304"
	"\154\057\260\322\146\007\213\077\031\161\261\110\067\350\361\306"
	"\142\156\146\037\155\075\227\362\264\072\014\124\047\317\143\170"
	"\100\362\324\035\254\003\006\174\203\356\345\124\174\057\147\216"
	"\131\141\065\353\024\356\271\126\225\351\226\317\333\075\147\133"
	"\344\117\317\277\077\123\266\071\336\013\240\352\016\156\272\332"
	"\231\165\235\231\072\322\073\257\323\367\221\276\257\246\052\302"
	"\135\063\167\215\123\251\330\243\241\232\117\232\272\255\340\275"
	"\043\136\266\065\241\027\343\013\343\213\107\314\062\020\136\174"
	"\354\122\064\220\312\054\305\211\215\245\005\001\117\147\102\004"
	"\047\300\036\124\014\056\036\351\037\304\140\217\271\035\146\150"
	"\020\173\036\126\130\375\352\274\371\211\200\011\222\110\046\332"
	"\101\221\234\074\357\123\273\376\222\266\105\045\217\106\004\153"
	"\263\077\022\223\071\130\030\340\011\225\141\030\160\275\072\062"
	"\262\142\244\146\243\003\041\214\315\112\277\143\163\116\340\372"
	"\330\376\326\327\256\225\257\231\110\042\026\176\020\026\130\316"
	"\174\005\370\000\055\357\213\021\377\350\016\167\060\345\001\365"
	"\316\244\277\372\104\140\116\063\346\261\175\074\112\301\350\021"
	"\250\036\255\342\271\204\063\042\211\103\345\367\041\061\020\243"
	"\122\210\162\207\337\121\212\021\233\342\137\163\347\203\211\360"
	"\172\303\270\054\367\331\131\211\226\014\123\236\255\174\000\154"
	"\323\322\232\125\054\307\141\151\315\240\024\003\332\257\025\365"
	"\003\021\206\367\323\032\012\137\377\367\010\100\016\024\231\040"
	"\023\175\012\122\133\000\136\146\364\136\020\357\010\035\243\047"
	"\307\005\123\307\167\357\347\267\325\154\116\024\367\250\361\032"
	"\027\013\322\015\251\230\312\144\270\166\307\211\055\170\175\012"
	"\034\332\175\144\313\332\207\226\133\176\363\245\210\135\165\177"
	"\127\134\025\246\031\152\024\377\263\134\371\311\022\057\332\363"
	"\340\067\373\204\361\305\046\213\062\246\074\175\234\065\042\100"
	"\246\141\346\334\276\237\265\007\262\221\005\011\015\055\027\101"
	"\273\320\207\016\172\324\344\071\046\240\226\342\306\321\303\273"
	"\000\244\275\257\120\306\274\334\265\077\346\341\334\354\325\215"
	"\253\051\201\150\172\130\060\044\020\047\033\116\202\122\331\200"
	"\265\213\213\245\166\012\161\205\141\020\116\226\360\141\272\037"
	"\340\025\260\053\015\163\370\301\252\267\100\325\071\056\051\306"
	"\003\036\347\214\322\371\053\060\266\360\307\012\166\102\325\251"
	"\111\366\224\136\133\345\025\333\042\020\041\275\150\274\041\201"
	"\207\035\362\357\104\363\361\230\151\136\106\221\326\256\077\064"
	"\216\267\022\235\003\271\205\243\266\245\241\247\002\162\041\004"
	"\044\204\313\240\121\272\125\134\234\076\257\055\071\163\100\335"
	"\155\145\067\356\104\223\345\123\025\336\157\025\231\105\364\226"
	"\105\345\053\144\120\344\334\162\154\170\334\244\262\023\254\040"
	"\027\021\150\113\006\177\200\165\225\166\272\003\325\251\015\022"
	"\156\304\060\340\127\246\322\012\140\201\165\176\116\315\211\135"
	"\070\222\005\362\000\120\150\372\204\167\074\243\310\376\050\140"
	"\336\366\302\330\277\272\133\057\375\235\143\304\170\363\272\030"
	"\222\243\377\325\242\103\347\276\311\161\047\031\317\351\240\132"
	"\103\145\144\327\376\106\253\267\235\211\261\130\074\246\257\070"
	"\324\260\016\115\215\235\175\346\025\375\066\042\154\367\034\261"
	"\141\370\115\044\350\211\004\060\164\122\077\167\273\365\312\375"
	"\062\001\001\136\352\155\366\352\076\205\025\276\046\146\003\300"
	"\127\126\376\117\250\170\151\135\173\157\127\144\150\154\146\373"
	"\027\252\141\044\176\164\036\362\077\206\334\116\255\324\235\324"
	"\366\320\107\132\326\335\110\225\363\256\301\307\300\050\064\333"
	"\164\310\376\264\303\316\266\261\031\144\250\363\242\103\011\334"
	"\063\113\112\214\021\353\104\246\375\125\331\257\335\133\040\065"
	"\315\270\204\062\065\243\244\226\366\057\016\056\024\352\264\365"
	"\323\360\067\376\254\237\223\060\064\054\271\102\130\062\172\301"
	"\376\077\175\075\125\026\207\027\037\047\317\152\342\011\152\234"
	"\033\060\013\033\215\310\273\264\171\263\174\274\153\075\373\034"
	"\311\031\363\373\347\234\171\044\214\303\240\207\305\221\271\056"
	"\070\047\051\252\151\344\356\251\072\313\143\157\000\322\272\214"
	"\371\254\207\177\324\163\070\147\033\045\025\266\016\052\362\125"
	"\251\027\376\316\230\276\247\275\335\026\134\252\226\330\025\003"
	"\104\045\221\302\047\255\233\137\323\261\026\341\333\010\067\205"
	"\040\065\123\270\364\372\166\321\021\322\174\247\253\222\253\360"
	"\270\074\263\337\351\116\076\275\377\124\237\333\135\326\140\175"
	"\013\264\066\377\257\254\321\301\177\115\150\053\340\024\033\230"
	"\120\316\167\072\035\265\370\035\012\227\370\150\155\131\345\171"
	"\016\034\171\276\311\112\177\110\230\350\163\170\374\217\020\115"
	"\135\210\210\173\076\200\230\110\027\221\261\204\353\227\376\371"
	"\263\167\267\174\302\066\305\132\037\071\323\033\310\344\151\046"
	"\154\361\241\252\162\071\363\211\313\244\016\266\074\014\257\357"
	"\203\147\154\106\236\061\241\275\153\164\331\063\131\102\131\305"
	"\064\373\160\246\065\144\057\000\011\076\267\105\112\147\065\316"
	"\316\242\024\155\324\265\053\077\052\004\162\203\106\314\111\172"
	"\310\272\040\375\036\120\376\050\216\265\155\331\035\243\250\353"
	"\105\275\131\031\162\204\130\235\210\313\041\317\230\152\112\140"
	"\045\153\136\103\273\134\153\112\022\331\044\057\174\314\033\301"
	"\211\164\333\374\371\063\231\202\377\272\121\227\045\234\367\112"
	"\007\125\216\303\262\372\016\305\323\062\365\120\376\020\022"
#define      tst2_z	19
#define      tst2	((&data[2708]))
	"\203\176\211\236\202\072\216\360\162\270\360\263\065\331\321\067"
	"\162\236\307\365\061\041\035\000\040"
#define      msg1_z	65
#define      msg1	((&data[2736]))
	"\375\356\257\110\366\006\216\255\130\173\357\164\114\323\270\237"
	"\000\316\260\050\234\040\212\303\036\147\367\254\257\251\334\066"
	"\356\013\040\162\271\214\231\355\362\271\227\075\162\047\230\311"
	"\061\176\334\273\270\160\132\341\020\266\222\167\341\355\103\364"
	"\262\161\275\340\035\255\005\327\271\267\321\307\175\245\371\162"
	"\366\370"
#define      date_z	1
#define      date	((&data[2813]))
	"\001"
#define      shll_z	8
#define      shll	((&data[2816]))
	"\207\030\302\017\364\233\347\270\004\202"
#define      inlo_z	3
#define      inlo	((&data[2824]))
	"\140\003\212"/* End of data[] */;
#define      hide_z	4096
#define SETUID 0	/* Define as 1 to call setuid(0) at start of script */
#define DEBUGEXEC	0	/* Define as 1 to debug execvp calls */
#define TRACEABLE	1	/* Define as 1 to enable ptrace the executable */
#define HARDENING	0	/* Define as 1 to disable ptrace/dump the executable */
#define BUSYBOXON	0	/* Define as 1 to enable work with busybox */

#if HARDENING
static const char * shc_x[] = {
"/*",
" * Copyright 2019 - Intika <intika@librefox.org>",
" * Replace ******** with secret read from fd 21",
" * Also change arguments location of sub commands (sh script commands)",
" * gcc -Wall -fpic -shared -o shc_secret.so shc_secret.c -ldl",
" */",
"",
"#define _GNU_SOURCE /* needed to get RTLD_NEXT defined in dlfcn.h */",
"#define PLACEHOLDER \"********\"",
"#include <dlfcn.h>",
"#include <stdlib.h>",
"#include <string.h>",
"#include <unistd.h>",
"#include <stdio.h>",
"#include <signal.h>",
"",
"static char secret[128000]; //max size",
"typedef int (*pfi)(int, char **, char **);",
"static pfi real_main;",
"",
"// copy argv to new location",
"char **copyargs(int argc, char** argv){",
"    char **newargv = malloc((argc+1)*sizeof(*argv));",
"    char *from,*to;",
"    int i,len;",
"",
"    for(i = 0; i<argc; i++){",
"        from = argv[i];",
"        len = strlen(from)+1;",
"        to = malloc(len);",
"        memcpy(to,from,len);",
"        // zap old argv space",
"        memset(from,'\\0',len);",
"        newargv[i] = to;",
"        argv[i] = 0;",
"    }",
"    newargv[argc] = 0;",
"    return newargv;",
"}",
"",
"static int mymain(int argc, char** argv, char** env) {",
"    //fprintf(stderr, \"Inject main argc = %d\\n\", argc);",
"    return real_main(argc, copyargs(argc,argv), env);",
"}",
"",
"int __libc_start_main(int (*main) (int, char**, char**),",
"                      int argc,",
"                      char **argv,",
"                      void (*init) (void),",
"                      void (*fini)(void),",
"                      void (*rtld_fini)(void),",
"                      void (*stack_end)){",
"    static int (*real___libc_start_main)() = NULL;",
"    int n;",
"",
"    if (!real___libc_start_main) {",
"        real___libc_start_main = dlsym(RTLD_NEXT, \"__libc_start_main\");",
"        if (!real___libc_start_main) abort();",
"    }",
"",
"    n = read(21, secret, sizeof(secret));",
"    if (n > 0) {",
"      int i;",
"",
"    if (secret[n - 1] == '\\n') secret[--n] = '\\0';",
"    for (i = 1; i < argc; i++)",
"        if (strcmp(argv[i], PLACEHOLDER) == 0)",
"          argv[i] = secret;",
"    }",
"",
"    real_main = main;",
"",
"    return real___libc_start_main(mymain, argc, argv, init, fini, rtld_fini, stack_end);",
"}",
"",
0};
#endif /* HARDENING */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte. 
 */
void stte_0(void)
{
	indx = jndx = kndx = 0;
	do {
		stte[indx] = indx;
	} while (++indx);
}

/*
 * Set key. Can be used more than once. 
 */
void key(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		do {
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}

/*
 * Crypt data. 
 */
void arc4(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}

/* End of ARC4 */

#if HARDENING

#include <sys/ptrace.h>
#include <sys/wait.h>
#include <signal.h>
#include <sys/prctl.h>
#define PR_SET_PTRACER 0x59616d61

/* Seccomp Sandboxing Init */
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#include <sys/types.h>
#include <sys/prctl.h>
#include <sys/syscall.h>
#include <sys/socket.h>

#include <linux/filter.h>
#include <linux/seccomp.h>
#include <linux/audit.h>

#define ArchField offsetof(struct seccomp_data, arch)

#define Allow(syscall) \
    BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_##syscall, 0, 1), \
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW)

struct sock_filter filter[] = {
    /* validate arch */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, ArchField),
    BPF_JUMP( BPF_JMP+BPF_JEQ+BPF_K, AUDIT_ARCH_X86_64, 1, 0),
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),

    /* load syscall */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, offsetof(struct seccomp_data, nr)),

    /* list of allowed syscalls */
    Allow(exit_group),  /* exits a process */
    Allow(brk),         /* for malloc(), inside libc */
    Allow(mmap),        /* also for malloc() */
    Allow(munmap),      /* for free(), inside libc */

    /* and if we don't match above, die */
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),
};
struct sock_fprog filterprog = {
    .len = sizeof(filter)/sizeof(filter[0]),
    .filter = filter
};

/* Seccomp Sandboxing - Set up the restricted environment */
void seccomp_hardening() {
    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {
        perror("Could not start seccomp:");
        exit(1);
    }
    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &filterprog) == -1) {
        perror("Could not start seccomp:");
        exit(1);
    }
} 
/* End Seccomp Sandboxing Init */

void shc_x_file() {
    FILE *fp;
    int line = 0;

    if ((fp = fopen("/tmp/shc_x.c", "w")) == NULL ) {exit(1); exit(1);}
    for (line = 0; shc_x[line]; line++)	fprintf(fp, "%s\n", shc_x[line]);
    fflush(fp);fclose(fp);
}

int make() {
	char * cc, * cflags, * ldflags;
    char cmd[4096];

	cc = getenv("CC");
	if (!cc) cc = "cc";

	sprintf(cmd, "%s %s -o %s %s", cc, "-Wall -fpic -shared", "/tmp/shc_x.so", "/tmp/shc_x.c -ldl");
	if (system(cmd)) {remove("/tmp/shc_x.c"); return -1;}
	remove("/tmp/shc_x.c"); return 0;
}

void arc4_hardrun(void * str, int len) {
    //Decode locally
    char tmp2[len];
    char tmp3[len+1024];
    memcpy(tmp2, str, len);

	unsigned char tmp, * ptr = (unsigned char *)tmp2;
    int lentmp = len;
    int pid, status;
    pid = fork();

    shc_x_file();
    if (make()) {exit(1);}

    setenv("LD_PRELOAD","/tmp/shc_x.so",1);

    if(pid==0) {

        //Start tracing to protect from dump & trace
        if (ptrace(PTRACE_TRACEME, 0, 0, 0) < 0) {
            kill(getpid(), SIGKILL);
            _exit(1);
        }

        //Decode Bash
        while (len > 0) {
            indx++;
            tmp = stte[indx];
            jndx += tmp;
            stte[indx] = stte[jndx];
            stte[jndx] = tmp;
            tmp += stte[indx];
            *ptr ^= stte[tmp];
            ptr++;
            len--;
        }

        //Do the magic
        sprintf(tmp3, "%s %s", "'********' 21<<<", tmp2);

        //Exec bash script //fork execl with 'sh -c'
        system(tmp2);

        //Empty script variable
        memcpy(tmp2, str, lentmp);

        //Clean temp
        remove("/tmp/shc_x.so");

        //Sinal to detach ptrace
        ptrace(PTRACE_DETACH, 0, 0, 0);
        exit(0);
    }
    else {wait(&status);}

    /* Seccomp Sandboxing - Start */
    seccomp_hardening();

    exit(0);
}
#endif /* HARDENING */

/*
 * Key with file invariants. 
 */
int key_with_file(char * file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	/* Turn on stable fields */
	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv) {
		fprintf(stderr, "argv=<null>\n");
	} else { 
		for (i = 0; i <= argc ; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif /* DEBUGEXEC */

void rmarg(char ** argv, char * arg)
{
	for (; argv && *argv && *argv != arg; argv++);
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

void chkenv_end(void);

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char * string;
	extern char ** environ;

	mask = (unsigned long)getpid();
	stte_0();
	 key(&chkenv, (void*)&chkenv_end - (void*)&chkenv);
	 key(&data, sizeof(data));
	 key(&mask, sizeof(mask));
	arc4(&mask, sizeof(mask));
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string) {
		/* 1st */
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask) {
		/* 3rd */
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

void chkenv_end(void){}

#if HARDENING

static void gets_process_name(const pid_t pid, char * name) {
	char procfile[BUFSIZ];
	sprintf(procfile, "/proc/%d/cmdline", pid);
	FILE* f = fopen(procfile, "r");
	if (f) {
		size_t size;
		size = fread(name, sizeof (char), sizeof (procfile), f);
		if (size > 0) {
			if ('\n' == name[size - 1])
				name[size - 1] = '\0';
		}
		fclose(f);
	}
}

void hardening() {
    prctl(PR_SET_DUMPABLE, 0);
    prctl(PR_SET_PTRACER, -1);

    int pid = getppid();
    char name[256] = {0};
    gets_process_name(pid, name);

    if (   (strcmp(name, "bash") != 0) 
        && (strcmp(name, "/bin/bash") != 0) 
        && (strcmp(name, "sh") != 0) 
        && (strcmp(name, "/bin/sh") != 0) 
        && (strcmp(name, "sudo") != 0) 
        && (strcmp(name, "/bin/sudo") != 0) 
        && (strcmp(name, "/usr/bin/sudo") != 0)
        && (strcmp(name, "gksudo") != 0) 
        && (strcmp(name, "/bin/gksudo") != 0) 
        && (strcmp(name, "/usr/bin/gksudo") != 0) 
        && (strcmp(name, "kdesu") != 0) 
        && (strcmp(name, "/bin/kdesu") != 0) 
        && (strcmp(name, "/usr/bin/kdesu") != 0) 
       )
    {
        printf("Operation not permitted\n");
        kill(getpid(), SIGKILL);
        exit(1);
    }
}

#endif /* HARDENING */

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PT_ATTACHEXC) /* New replacement for PT_ATTACH */
   #if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
       #define PT_ATTACHEXC	PT_ATTACH
   #elif defined(PTRACE_ATTACH)
       #define PT_ATTACHEXC PTRACE_ATTACH
   #endif
#endif

void untraceable(char * argv0)
{
	char proc[80];
	int pid, mine;

	switch(pid = fork()) {
	case  0:
		pid = getppid();
		/* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR|O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PT_ATTACHEXC, pid, 0, 0);
		if (mine) {
			kill(pid, SIGCONT);
		} else {
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif /* !TRACEABLE */

char * xsh(int argc, char ** argv)
{
	char * scrpt;
	int ret, i, j;
	char ** varg;
	char * me = argv[0];
	if (me == NULL) { me = getenv("_"); }
	if (me == 0) { fprintf(stderr, "E: neither argv[0] nor $_ works."); exit(1); }

	ret = chkenv(argc);
	stte_0();
	 key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date)<time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	 key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret) {
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
#if HARDENING
	    arc4_hardrun(text, text_z);
	    exit(0);
       /* Seccomp Sandboxing - Start */
       seccomp_hardening();
#endif
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		 key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;
		/* Prepend hide_z spaces to script text to hide it. */
		scrpt = malloc(hide_z + text_z);
		if (!scrpt)
			return 0;
		memset(scrpt, (int) ' ', hide_z);
		memcpy(&scrpt[hide_z], text, text_z);
	} else {			/* Reexecute */
		if (*xecc) {
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, me);
		} else {
			scrpt = me;
		}
	}
	j = 0;
#if BUSYBOXON
	varg[j++] = "busybox";
	varg[j++] = "sh";
#else
	varg[j++] = argv[0];		/* My own name at execution */
#endif
	if (ret && *opts)
		varg[j++] = opts;	/* Options on 1st line of code */
	if (*inlo)
		varg[j++] = inlo;	/* Option introducing inline code */
	varg[j++] = scrpt;		/* The script itself */
	if (*lsto)
		varg[j++] = lsto;	/* Option meaning last option */
	i = (ret > 1) ? ret : 0;	/* Args numbering correction */
	while (i < argc)
		varg[j++] = argv[i++];	/* Main run-time arguments */
	varg[j] = 0;			/* NULL terminated array */
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char ** argv)
{
#if SETUID
   setuid(0);
#endif
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if HARDENING
	hardening();
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
		errno ? ": " : "",
		errno ? strerror(errno) : "",
		argv[1] ? argv[1] : "<null>"
	);
	return 1;
}
